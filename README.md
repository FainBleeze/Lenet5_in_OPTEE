# Lenet5_in_TEE



## 一、初步分析



### 1. 一般环境下的Lenet5源码

##### 代码来源

本应用中使用的Lenet5源码来自于https://github.com/fan-wenjie/LeNet-5

该项目使用**C语言**完成，没有依赖其他第三方库，在windows和Linux环境下通过简单的编译和极少的改动即可正确运行



##### 代码结构

代码结构如下：

- lenet.h：定义结构变量，提供神经网络接口
- lenet.c：实现卷积神经网络的主要计算功能，提供初始化、训练和预测接口的具体实现
- main.c：打开训练集并分组，调用卷积神经网络接口训练模型，并针对测试集给出预测结果
- 训练集与测试集



##### 执行分析

程序运行一次的执行流程如下：

1. 读取数据集（训练集和测试集）
2. 模型初始化
3. 训练集分组
4. 训练模型
5. 模型测试
6. 统计数据



### 2. TEE中的Lenet5

##### 总体目标

现有的代码可以在Rich OS中编译执行，但不可以直接放在TEE环境中执行。

本项目的目标是将卷积神经网络的计算过程与TEE（可信执行环境）相结合，作为TEE实验的初次尝试。



##### 项目规划

一个TEE中的安全应用分为两部分，分别是在安全环境中执行的**安全应用TA**和在非安全环境中执行的**客户应用CA**

2. TEE通过共享内存的方式与Linux中的应用进行通信，共享内存的大小有限；

3. CPU在安全世界和非安全世界之间进行一次切换需要进行多次系统调用和上下文切换，频繁切换会带来性能上的损耗

考虑到以上几点因素，TEE中的代码应该尽量少，即只将关键的功能函数放入TEE执行。同时，衡量第12点带来的数据大小的限制和第2点带来的性能损耗，提出的第一个设计方案如下：

- 训练阶段
  - 客户应用CA：打开整个训练集并进行分组，调用TA中的接口进行训练
  - 安全应用TA：每次接收一组数据，对模型进行训练，模型参数保存在TEE内部以利用TEE的安全性，除了执行结果不返回任何值
- 测试阶段
  - 客户应用CA：打开整个测试集并进行分组，调用TA中的接口进行预测
  - 安全应用TA：接受一组数据，使用训练好的模型进行预测，返回预测结果



### 3. 实现步骤

1. ta/lenet5_ta.c：参考OP-TEE的样例程序，完成TA中必要的入口函数，并向 Client 提供三个功能调用接口：模型初始化接口、训练模型接口、预测接口（具体功能暂不实现）
2. host/main.c：修改原lenet5程序的main.c作为Client APP，负责打开文件，分组调用TA中的接口完成训练、预测的功能。
3. ta/lenet5_ta.c：框架完成以后，实现TA中具体的功能函数。在这些函数中需要检查参数确保安全性，最终调用原lenet.c中实现的功能完成函数需求。
4. 编译newlib开源程序库，为lenet5中需要的exp、sqrt等数学运算提供支持



### 4. 主要问题

##### 参数的传递

CA每次调用TA时可以提供四个参数，每个参数仅有64位的地址空间，可以用来传递两个32位int，或者提供一片共享内存的缓冲区（起始指针和缓冲区大小），内存在共享时受到OP-TEE OS的保护，除了TA和CA，其他程序无法访问或篡改。在本实验中由于数据量很大，显然缓冲区更适合作为参数



##### 数学库

C语言的标准库有libc和libm两种，<math.h>位于libm中。

lenet5的源码需要使用exp、sqrt两个浮点运算函数，不可避免地使用了<math.h>头文件。在Linux中编译时，可以通过GCC -lm的参数设置找到libm。

但是，OP-TEE中仅有对libc的支持，没有libm，于是我们需要手动地实现这两个函数，或者将开源的数学库编译成静态库加入到OP-TEE的源码当中。

###### 静态链接库

为了满足日后可能使用其他数学算法库的需要，这里首先尝试了使用加入静态库的方法：

- newlib是一个广泛应用于嵌入式系统的开源C语言库，其中包含了对libm的支持。我尝试在ubuntu虚拟机中将newlib编译到ARM内核上，但是编译过程中遇到了一些问题，没有成功。nwelib的官方文档关于交叉编译的内容极少，因此尝试了一段时间后决定将其搁置

###### 添加函数

由于newlib编译失败，为了不影响整体进度，决定手动添加的sqrt和exp的函数实现代替<math.h>使安全应用能够正常运行起来，后续回顾时再考虑静态库的编译。

最终采用的解决方案是引用了另一个开源数学运算库fblibm的头文件和两个运算函数，加入到TA的源码中替代<math.h>

在Windos下对使用fblibm函数和使用<math.h>的两种模型进行对比，发现该函数和库文件中的函数性能差别不大：

|                |  fblibm  |  标准库  |
| :------------: | :------: | :------: |
| 平均预测准确率 | 96.99 %  | 97.15 %  |
|   平均总耗时   | 81.971 s | 82.072 s |

